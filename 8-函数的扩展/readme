关键词：

函数参数的默认值，自动调用let或者const，所以不能用let或const再次声明。

通常情况下，定义了默认值的参数，应该是函数的尾参数。  f(1,,2)这样会报错

函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
函数的length属性的含义是，该函数预期传入的参数个数。同理，rest参数也不会计入length属性。
如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。(function (a, b = 1, c) {}).length;// 1

如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。

典型作用域案例，"把玩"挺有意思
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}
foo() // 3

扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
console.log(...[1, 2, 3]);// 1 2 3 该运算符主要用于函数调用。

扩展运算符的应用:
    1.合并数组[...arr1, ...arr2, ...arr3]
    2.与解构赋值结合[a, ...rest] = list
        const [first, ...rest] = [1, 2, 3, 4, 5];
        first // 1
        rest  // [2, 3, 4, 5]
如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。

函数的name属性，返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。

箭头函数有几个使用注意点。
（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。

箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。

除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。

！！！函数绑定问题有点难

函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。

尾调用优化：就是指某个函数的最后一步是调用另一个函数

尾递归：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。

递归优化：把递归函数编程尾递归函数，方法是把中间过程需要的变量变成函数参数，然后在最后一步调用自己